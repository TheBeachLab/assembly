gavrasm Gerd's AVR assembler version 4.6 (C)2019 by DG4FAC
----------------------------------------------------------
Source file: blink.asm
Hex file:    blink.hex
Eeprom file: blink.eep
Compiled:    25.05.2020, 02:54:41
Pass:        2
     1: ; Hello world blink
     2: ; by Fran Sanchez 2020
     3: ; DWTFYW license
     4: ; this code blinks the internal led
     5: ; every half a second
     6: ; at 16MHz is 8M clock cycles
     7: 
     8: .INCLUDE "m328pdef.inc"	; directive to include 
 -> Warning 009: Include defs not necessary, using internal values!
   File: blink.asm, Line: 8
   Source line: .INCLUDE "m328pdef.inc"	; directive to include 
     9: .ORG 0x0000		; the next instruction has to be written to address 0x0000
    10: 
    11: 000000   C000  rjmp START	; the reset vector: jump to "main"
    12: 
    13: START:
    14: 
    15: ; set up the sram stack SPL:HPL
    16: ; SPL stack pointer low, SPH stack pointer high
    17: ; SPH needed because
    18: ; atmega328 has 2kb sram
    19: ; stack not used in this example
    20: 000001   EF0F  ldi r16, low(RAMEND)	; load the start address of the sram in r16
    21: 000002   BF0D  out SPL, r16		; store r16 (start address) in SPL register
    22: 000003   E008  ldi r16, high(RAMEND)	; load the end address of the sram in r16
    23: 000004   BF0E  out SPH, r16		; store r16 (end address) in SPH register
    24: 
    25: ; set up DDRB where led is located
    26: 000005   EF0F  ldi r16, 0xFF	; load register 16 with 0xFF (all bits 1)
    27: 000006   B904  out DDRB, r16	; write the value in r16 (0xFF) to DDRB   
    28: 
    29: LOOP:  
    30: 000007   9A2D  sbi PORTB, 5	; switch on the LED  
    31: 000008   D003  rcall delay_05	; wait for half a second  
    32: 000009   982D  cbi PORTB, 5	; switch it off  
    33: 00000A   D001  rcall delay_05	; wait for half a second  
    34: 00000B   CFFB  rjmp LOOP	; jump to loop
    35: 
    36: DELAY_05:	; the subroutine:  
    37: 00000C   E10F  ldi r16, 31	; 1cc load r16 with 31
    38: 
    39: OUTER_LOOP:		; outer loop label  
    40: 00000D   EF8D  ldi r24, low(1021)	; load registers r24:r25 with 1021, our new init value  
    41: 00000E   E093  ldi r25, high(1021)	; 2cc total
    42: 
    43: DELAY_LOOP:	; the loop label         
    44: 00000F   9601  adiw r24, 1	; 2cc - increment word r24:r25    
    45: 000010   F7F1  brne DELAY_LOOP	; 2cc - if no overflow ("branch if not equal to 0"), go back to "delay_loop"
    46: ; outer loop takes
    47: ; 2cc for the 2 ldi
    48: ; + the delay loop
    49: ; if r24:r25 was loaded with 0, it would overflow at 65535
    50: ; 65535*4=262140 cc
    51: ; + 3cc overflow
    52: ; total 262145 
    53: 
    54: 000011   950A  dec r16		; 1cc decrement r16  
    55: 000012   F7D1  brne OUTER_LOOP	; 2cc and loop if outer loop not finished
    56: ; +3 cc
    57: ; total 262148*31=8126588
    58: ; excess of 126588 cc
    59: ; load a bigger number in r24:r25
    60: ; 126588/31= 4083.48... cc
    61: ; redo the math
    62: ; (65535-1021)*4=258056 cc + 3cc overflow + 2cc ldi = 258061 cc
    63: ; +3cc = 258064*31=7999984
    64: ; +8cc overfow + 1cc ldi r16 + 1cc rcall + 1cc ret = 7999995 cc
    65:   
    66: 000013   9508  ret	; 1cc return from rcall subroutine

Program             :       20 words.
Constants           :        0 words.
Total program memory:       20 words.
Eeprom space        :        0 bytes.
Data segment        :        0 bytes.
Compilation completed, no errors.
Compilation endet 25.05.2020, 02:54:41
